
#Software Construction

    Assume Environment (E) is STATIC. 
    E = Perfect 2D world that agents 'live' in.
    No environmental factors.
    All agent interaction in 2D vector space.
    All agents perfect (constant) health until death.
    
    Visual Predators (VP) QUASI-POPULATION. Optional ageing and starvation, simple Sexual Reproduction.
    VP competitive, non-grouping.
    Model process of visual identification of prey agents, based on distance from VP and colour distance/differentiation from VP's imprinted bias towards its target "image" of a prey agent.
    Imprinted/Target colour and facing direction present in visual representation.
    
    Colour-Polymorphic Prey (CPP) GENUINE POPULATION. Variation, reproduction, mutation, ageing
    CPP 'death' from consumption by VP and expired lifespan.
    Assume food omnipresent in E for CPP.
    Variations and Mutations reflected in individual agent Colouring.
    Colouring present in visual representation.

	All metrics in floating-point values, with *parameters* operating between 0.000 and 1.000, where 0 = "no effect" or "0%", and 1 = "maximum effect" or "100%".

<br>

From the beginning, given that modularity was a known requirement, the development process needed to be as organised and orderly as possible: building complete, foundational components which can reliably inter-operate and be used as cogs in the *engine* for the ABM.

One of my personal requirements was that the project be *open-source* for two reasons:

 1. When developing a program to test a research hypothesis it would seem essential that anybody should have free access interrogate the code base as a means of verifying the resultant data used in a publication.
 
 2. By using **[git](https://en.wikipedia.org/wiki/Git_%28software%29)** with the source code hosted by **[GitHub](www.github.com)** I would have free, standardised source code management. This is particularly a natural route by the fact that the command `go get` to copy and install a Go project uses **git** . 

<br>
###Dealing with Vector Geometries

The first consideration was to decide how a *vector* is to be represented programmatically before we can implement the functions necessary for computing movement and relational actions by agents in our 2D vector space. In **Go** the most important data structure for convenient and efficient means of working with sequences of typed data is a *slice*, a dynamic-sized array of elements stored in contiguous memory[^GoBlog-Slices]. By taking advantage of *slices* we can write general vector operations *(cross/dot product, scalar multiplication, vector distance, rotation, etc)* which are suitable for *n-dimensional* vectors. 
By defining a customised slice `type Vector []float64` we can pass a `Vector` of any length *(dimensionality)* to a function which expects a `Vector`, and then test for its length inside the function itself if needed. *(For example, to calculate the cross product of any two vectors, we cannot perform the operation on vectors of two different lengths, nor on vectors that are not three dimensional, so the cross product function must test for `Vector` length equality.)*

I began by constructing the necessary vector operations as a distinct Go *package*[^GoBlog-packages] named **`geometry`** made up of small, reliable functions, covering the gamut of operations I would need, and which I could easily add to later.

<pre class="prettyprint"><code class="go">
// Vector : Any sized dimension representation of a point of vector space.
type Vector []float64

// VecScalarMultiply - performs scalar multiplication on a vector v, s.t. scalar * v = [scalar*e1, scalar*e2, scalar*e3]
func VecScalarMultiply(v Vector, scalar float64) (Vector, error) {
	if len(v) == 0 {
		return nil, errors.New("v is an empty vector")
	}
	var sm Vector
	for i := range v {
		sm = append(sm, (v[i] * scalar))
	}
	return sm, nil
}
<br></font></code></pre>
<center><small>*Example function from geometry package*</font>
<br>

I then created unit tests for each function, providing static and random inputs to test against when making any changes to the codebase.

![enter image description here](http://i.imgur.com/VTi8ve9.png)
<CENTER><small>*Agent movement is accomplished in two steps: first, rotation, then a scalar on the unit directional vector.*
<br>

###Colour
As colouration would be the key aspect in defining our *CP Prey* agents and their relation to the *VP* agents which are hunting them, I needed to create simple structures and methods which encapsulated the use of "Colour" and allow for it be used independently of implementation details. Although small, I decided to create `colour`  as a separate package as I had done with `geometry`.

Programmatically, a Colour instance `colour.RGB` is a three-channel (Red, Green, Blue) identity represented as floating-point values within $[0, 1]\,$;  where $\text{colour(}0,0,0)=\,$ `colour.RGB{0.0, 0.0, 0.0}`  is black, and $\text{ colour(}1,1,1)=\,$ `colour.RGB{1.0, 1.0, 1.0}` is white. This is consistent with our metric standards, which means values from a `colour.RGB` instance do not need to be converted/cast when interacting with any others in the $\text{ABM-CP}$ computation.

<br>
<pre class="prettyprint"><code class="golang">type RGB struct {
	Red   float64 `json:"red"`
	Green float64 `json:"green"`
	Blue  float64 `json:"blue"`
}</code></pre>
<CENTER><font size="3">*colour.RGB struct type with JSON encoding fields*</font></CENTER>

<pre class="prettyprint"><code class="golang">func RGBDistance(c1 RGB, c2 RGB) float64 {
	red := math.Abs(c1.Red - c2.Red)
	green := math.Abs(c1.Green - c2.Green)
	blue := math.Abs(c1.Blue - c2.Blue)
	return calc.ToFixed(((red + blue + green) / 3.0), 3) 
	// returns to 3 d.p. only
}</code></pre>

The above function quantifies the value difference between two `colour.RGB`s, returning a positive or negative floating-point ratio from 0.0 to 1.0. 
*n.b. The signed value is necessary to differentiate between sets of colours which might have the same "absolute" distance of value.*

<br>
##Modelling

The `abm` package is effectively an entire program without a direct executable interface. Each time a **Model** is created by the user of the package, that is logically equivalent to the creation of a subprogram by the caller software, designed to be run concurrent with the caller which acts as the *supervisor* to the `abm` process.
<br>
<pre class="prettyprint"><code class="golang">type Model struct {
	timestamp string // instance inception time
	running   bool
	Timeframe        //  embedded Model clock
	Environment      //  embedded environment attributes
	ConditionParams  //	embedded local model conditions and constraints
	AgentPopulations //	embedded slices of each agent type
	
	Om          chan gobr.OutMsg        // Outgoing comm channel
	Im          chan gobr.InMsg         // Incoming comm channel
	e           chan error              // error message channel
	Quit        chan struct{}           // client monitor signal
	rq          chan struct{}           // RUN stop signal
	render      chan render.AgentRender // VIS message channel
	
	turnSync    *gobr.SignalHub         // synchronisation
	
	Stats     // embedded global agent population statistics
	DatBuf    // embedded buffer of agent pop record for LOG
}</code></pre>
<br>

The data and execution of each $\,\text{ABM-CP}\,$ session is held in the **Model** structure, with *each instance acting as the working encapsulation of the modelling session*, collecting the necessary substructures with the accompanying operations as methods on the `struct` type. 

###Client Wrapper

![enter image description here](http://i.imgur.com/3NAwwcP.png)
<CENTER><font size="3">*A User establishes a connection to the supervisor process, which creates a new Model instance.*</font></CENTER>

As a **Model** executes 'blind' of the User connection type *(e.g. Web App GUI, remote/local command line, etc)*, it is embedded in a **Client** structure which facilitates external I/O and controls to the User with the correct interface *(e.g. WebSockets, SSH)*. This allows for multiple, concurrent modelling instances on a single host machine or server that runs the program, with the correct **Client** type enclosing the **Model** created by the *supervisor*.


![concurrent server connections](http://i.imgur.com/ZACpkGw.png)
<CENTER><font size="3">*The server encloses each Model instance in the correct Client implementation for the connection to the user.*</font></CENTER>

<br>
<pre class="prettyprint"><code class="golang">// WebScktClient wraps the Model, bridging it to the WebSocket user connection.
type WebScktClient struct {
	*websocket.Conn
	UUID string
	Name string
	*Model
	Active bool
	Dead   bool
	Stamp  time.Time
}</code></pre>
<CENTER><font size="3">*The Web User's Client implementation using WebSockets*</font></CENTER>
<br>


###Substructures

The substructures of each **Model** instance are the data representation of each modelling construct:

 - **Timeframe**  $\ $structure to represent in-model clock as `TURNS :: PHASES :: ACTIONS`
 
 - **ConditionParams**  $\ $structure is the collection of the static (constant) modelling parameters set by the user at inception.
 
 - **Environment**  $\ $structure which specifies the boundary / dimensions of the working model.

 - **Agent Populations**  $\ $are the set of active Prey and Predator agents in the running model for the current *turn*, stored as *slices* of individual agents.
<br>

In addition, each **Model** stores statistical data (**Stats**) and holds a single-turn buffer of the AgentPopulations (**DatBuf**) in memory to be written to log files concurrently to the $\ \text{ABM-CP}\ $ computation.

###Orchestration

In order to *orchestrate* between the concurrent processes of each modelling session, a **Model** uses **channels** which *share memory by communicating*, allowing the data passing between **goroutines** to simultaneously coordinate activity through the **select** statement. [^Concurrency-appendix]
As with all member variables inside user `struct` types in Go, publicly accessible channels are those whose names begin with a capital letter: $\ $The `Om` and `Im` channels provide I/O between the **Model** instance and the User controls *(via the supervisor process)*, while the `Quit` channel is used to safely end the $\,\text{ABM-CP}\,$ session. The internal channels communicate between concurrent methods of the **Model** instance.  (Usage is described in the 'Execution' section.)


Each **Model** instance also holds an embedded pointer to a concurrent `SignalHub`[^SignalHub] which is used to broadcast *turn synchronisation* messages (using a `map` of channels) to registered **goroutines** operating concurrently to one other:

![signalHub broadcast](http://i.imgur.com/ofezPpa.png)

The *`Broadcast()`* method on the `SignalHub` *blocks* the broadcasting goroutine until all registered goroutines retrieve the signal message – thereby forcing Model synchronisation between every Turn. [^turn-sync-blocking] 


###Managing Agent Populations

As mentioned above, a population, *or set*, of a given agent type is stored as a slice. When necessary for agents to be quickly partitioned into subsets or added into new collections, pointers to agents within the master populations were used, therefore reducing the need to copy agent states unnecessarily. Using slices to manage fluid groups of agents combines the advantages of linked-lists with direct/random element access of an array, and without the need to change any notation as Go automatically dereferences pointers by default.
Using pointers to subsets of a Population allows for the dynamic sorting necessary for Visual Predators to search for nearby prey – in particular it meant that search parameters and methodologies could be swapped ad-hoc and safely tested against. If a *VP* successfully attacks *(consumes)* a *CP Prey*, rather than directly interfering with the Population, we just 'flag' the now-dead agent for removal by setting its lifespan to zero. 
This works because the slices which store the complete populations of each agent type are 'refreshed' every turn as a necessary condition of the dynamic expansion and contraction of agents. 
We begin with an empty set which will become the Population of agents for the next turn. Each agent from the Population of the current turn individually runs through the defined **Rule-Based Behaviour** algorithm for that type, which is implemented as a function returning a set *(as a slice)* of agents. If the agent is still alive during the turn then the agent is copied to the set that will be returned – If the agent 'spawns' during the turn, then its progeny are also added to the returning set. However, if the lifespan of an agent is $\,0$, then the agent which called the function in the first place is *not* copied to the returning set, and the memory resource for that particular agent instance will be garbage collected.  After each **RBB** function return, the new set/*slice* of agents is appended to the Population for the next turn. Finally, once the entire population has run through the **RBB** algorithm, the new population set for the next turn replaces the current one. By using the lifespan *(or hunger level of an individual agent)* as a 'flag' for removal we end up with a high-level *mark-during-sweep* algorithm inside the running of an $\text{ABM-CP}$ turn without any extra code. Also worth mentioning is that as the new *CP Prey* Population is contiguous in memory, it is ready to be searched by *VP* agents in the next phase of the current turn. Coupled with the efficiency and speed of Go's GC, this method has proven to be sufficiently fast without requiring premature optimisation.

<br>
<pre class="prettyprint"><code class="golang">func (c *ColourPolymorphicPrey) RBB(ctxt Context, popSize int) (newpop []ColourPolymorphicPrey) {
	newkids := []ColourPolymorphicPrey{}
	jump := ""
	// BEGIN
	jump = c.Age(ctxt)
	switch jump {
	case "DEATH":
		goto End
	case "SPAWN":
		progeny := c.Birth(ctxt)
		newkids = append(newkids, progeny...)
	case "FERTILE": 
		if popSize ≤ ctxt.CppPopulationCap {
			c.Reproduction(ctxt.CppReproductionChance, ctxt.CppGestation)
		}
		fallthrough
	case "EXPLORE":
		ϴ := calc.RandFloatIn(-ctxt.CppTurn, ctxt.CppTurn)
		c.Turn(ϴ)
		c.Move()
	}
	// add calling agent
	newpop = append(newpop, *c) 
End:
	// add the newly created children to the returning population
	newpop = append(newpop, newkids...)
	return
}</code></pre>
<CENTER><font size="3">*RBB (Rule Based Behaviour) implementation for CP Prey agent action for that phase of the current model turn.*</font></CENTER>
<br>


##Execution 'Engine'

Given that the project required concurrent **modelling computation**,  **visualisation**, and data **logging**, I ended up designing the structure of each $\,\text{ABM-CP}\,$ instance like a customisable 'engine', such that any number of processes could be attached, execute concurrently and inter-operate using Go's channels. 


Below is a summary of the **RUN**, **VIS**, and **LOG** processes which were implemented for $\,\text{ABM-CP}\,$.

###RUN (Modelling)

Continually executes all the logic and computation of a complete model **turn** until such time as it receives signal to end via channel. If receiving on the `Quit` channel, also passes on the `Stop` instruction.

*illustration of turn execution by RUN*

###VIS (Visualisation)

All agents in a given population, prior to exiting their

###LOG (Data Logging)

<br>

[^GoBlog-Slices]: <small>$\ $Gerrand, Andrew (2011). *The Go Blog, Go Slices: usage and internals.* 
http://blog.golang.org/go-slices-usage-and-internals</font>
$ $

[^GoBlog-packages]: <small>$\ $Ajmani, Sameer (2015). *The Go Blog: Package Names.* 
https://blog.golang.org/package-names</font>
><small>Go code is organized into packages. Within a package, code can refer to any identifier (name) defined within, while clients of the package may only reference the package's exported types, functions, constants, and variables. Such references always include the package name as a prefix: foo.Bar refers to the exported name Bar in the imported package named foo. Good package names make code better. A package's name provides context for its contents, making it easier for clients to understand what the package is for and how to use it. The name also helps package maintainers determine what does and does not belong in the package as it evolves. Well-named packages make it easier to find the code you need.

[^Concurrency-appendix]: <small>*See* 
$ $

[^SignalHub]: <small>The `SignalHub` is of my own design, used for one sender to broadcast a signal either to multiple receivers, or to arbitrary ones individually.
$ $

[^turn-sync-blocking]: <small>The performance impact of such blocking is negligible as certain processes only commence after a turn's end.
$ $